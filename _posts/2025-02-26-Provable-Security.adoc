---
title: Intro 
categories: [cryptography, provable security, asiidoc]
tags: [unibe]     # TAG names should always be lowercase
math: true
---

== The basics of provable security

=== Kerkhoff's principle
[Note]
----
No security by obscurity.
----
Security shall depend on the key only, we have many of them, but if the algorithm is secret and an attacker finds it, we have to develop a new algorithm. 

=== Provable security
Remember the one-time pad. It's provably securein a probabilistic model. Can we have the same security but with shorter key than the message? Remember Entropy and so on. Thus the key needs the same length as the message or the same entropy.

==== Information-theoretic security
We permit that an adversary performs arbitrary computations, infinitely fast. 

This model is to strong.

==== Computational security
Computation cannot be infinitely fast. 

==== Formalizing symmetric-key encryption
We have the following syntax:

*Def* A symmetric symm-key encr schene $\Sigma$ has 3 algorithms.

1. $KeyGen() \rightarrow k$ , randomized algorithm
2. $Enc(k,m) \rightarrow c$, randomized
3. $Dec(k,c) \rightarrow m$, deterministic

*Notation* $\Sigma = (\Sigma .KeyGen, \Sigma .Enc, \Sigma .Dec)$

* Ky space $K$
* Message space $M$
* Cipher space $C$

==== Correctness
*Def* An encryption scheme $\Sigma$ is correct if

$\forall k \in K, \forall m \in M$ it holds

$\Sigma.Dec(k,Enc(k,m))=m$

[Note] 
----
We want the scheme to be correct for all messages. For the one-time pad, we showed this. Correctnes is also given for the identity function.
----

==== Security
Much more difficult than correctnes. We can send just a random string, this is then not correct. 

*Security against an adversary A*

* What does A learn? -> c
* in OTP how we proved thos. See before. 











